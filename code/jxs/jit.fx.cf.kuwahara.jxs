<jittershader name="jit.fx.cf.kuwahara">
	<description> An Anisotropic Kuwahara filter </description>
	<param name="tex0" type="int" default="0" />
	<param name="tensorTex" type="int" default="1" />
	<param name="textureMatrix0" type="mat4" state="TEXTURE0_MATRIX" />
	<param name="uv" type="vec2" state="TEXCOORD" />
	<param name="kernel_size" type="int" default="14" />
	<param name="alpha" type="float" default="0.1" />
    <param name="texDim" type="vec2" state="TEXDIM0" />
    <param name="hardness" type="float" default="100.0" />
	<language name="glsl" version="1.5">
		<bind param="tex0" program="fp" />
		<bind param="tensorTex" program="fp" />
		<bind param="textureMatrix0" program="vp" />
		<bind param="uv" program="vp" />
		<bind param="kernel_size" program="fp"/>
		<bind param="alpha" program="fp" />
        <bind param="texDim" program="fp" />
        <bind param="hardness" program="fp" />
		<program name="vp" type="vertex"  >
<![CDATA[
#version 330 core

in vec2 uv;
out jit_PerVertex {
	vec2 uv;
    vec2 uvFlipped;
} jit_out;

uniform mat4 textureMatrix0;

void main(void) {
	gl_Position = vec4(uv*2-1, 0.0, 1.0);
	jit_out.uv = vec2(textureMatrix0*vec4(uv, 0., 1.));
    jit_out.uvFlipped = vec2(textureMatrix0*vec4(uv.x, 1 - uv.y, 0., 1.));
}
]]>
</program>

<program name="fp" type="fragment"  >
<![CDATA[
#version 330 core
#define PI 3.14159265358979323846
#define SQRT2 1.4142135624

in jit_PerVertex {
	vec2 uv;
    vec2 uvFlipped;
} jit_in;
layout (location = 0) out vec4 outColor;

uniform samplerJit0 tex0;
uniform samplerJit1 tensorTex;
uniform vec2 texDim;
/*
Generalized Kuwahara filter
- https://www.youtube.com/watch?v=LDhN-JK3U9g
- https://github.com/GarrettGunnell/Post-Processing/tree/main/Assets/Kuwahara%20Filter
*/

uniform int kernel_size;
uniform float alpha, hardness;
//const int _KernelSize = 10;
const int N = 8;
//const float alpha = 0.1;
const float q = 9.;
//const float _Hardness = 10.;
     

vec4 readTensor(ivec2 iuv){

    vec3 g = texelFetch(tensorTex, iuv).rgb;
    vec3 g2 = g*g;
    float l0 = g.y + g.x;
    float l1 = sqrt(g2.y - 2.0 * g.x * g.y + g2.x + 4.0 * g2.z);
    float lambda1 = 0.5 * (l0 + l1);
    float lambda2 = 0.5 * (l0 - l1);

    vec2 v = vec2(lambda1 - g.x, -g.z);
    float vLen = length(v);
    
    vec2 t = vLen > 0.0 ? v/vLen : vec2(0.0, 1.0);
    float phi = -atan(t.y, t.x);

    float A = (lambda1 + lambda2 > 0.0) ? (lambda1 - lambda2) / (lambda1 + lambda2) : 0.0;

    return vec4(t, phi, A);
}

 void main(){

    ivec2 iuv = ivec2(jit_in.uv);

    vec4 t = readTensor(ivec2(jit_in.uvFlipped));
 
    int kernelRadius = kernel_size / 2;
    float a = float(kernelRadius) * clamp((alpha + t.w) / alpha, 0.1f, 2.0f);
    float b = float(kernelRadius) * clamp(alpha / (alpha + t.w), 0.1f, 2.0f);
    float cos_phi = cos(t.z);
    float sin_phi = sin(t.z);

    mat2 R = mat2(cos_phi, -sin_phi, sin_phi, cos_phi);
    mat2 S = mat2(1/a, 0.0, 0.0, 1/b);
    mat2 SR = S * R;

    float a2 = a*a;
    float b2 = b*b;
    float cos_phi2 = cos_phi*cos_phi;
    float sin_phi2 = sin_phi*sin_phi;
    int max_x = int(sqrt(a2 * cos_phi2 + b2 * sin_phi2));
    int max_y = int(sqrt(a2 * sin_phi2 + b2 * cos_phi2));
    
    float zeta = 2.0f / float(kernelRadius);
    //float zeta = 0.01;
    
    float zeroCross = 2.0;
    
    float sinZeroCross = sin(zeroCross);
    float eta = (zeta + cos(zeroCross)) / (sinZeroCross * sinZeroCross);
    int k;
    vec4 m[N];
    vec3 s[N];
    
    
    for (k = 0; k < N; ++k) {
        m[k] = vec4(0.0f);
        s[k] = vec3(0.0f);
    }
    
    ivec2 upperLimit = ivec2(texDim-1);
    for (int y = -max_y; y <= max_y; ++y) {
        for (int x = -max_x; x <= max_x; ++x) {
            vec2 v = SR * vec2(x, y);
            vec3 c = texelFetch(tex0, clamp(iuv + ivec2(x, y), ivec2(0,0), upperLimit)).xyz;
            c = clamp(c,0.0,1.0) ;
            float sum = 0.;
            float w[8];
            float z, vxx, vyy;

            /* Calculate Polynomial Weights */
            vxx = zeta - eta * v.x * v.x;
            vyy = zeta - eta * v.y * v.y;
            z = max(0., v.y + vxx); 
            w[0] = z * z;
            sum += w[0];
            z = max(0., -v.x + vyy); 
            w[2] = z * z;
            sum += w[2];
            z = max(0., -v.y + vxx); 
            w[4] = z * z;
            sum += w[4];
            z = max(0., v.x + vyy); 
            w[6] = z * z;
            sum += w[6];
            v = SQRT2 / 2.0f * vec2(v.x - v.y, v.x + v.y);
            vxx = zeta - eta * v.x * v.x;
            vyy = zeta - eta * v.y * v.y;
            z = max(0., v.y + vxx); 
            w[1] = z * z;
            sum += w[1];
            z = max(0., -v.x + vyy); 
            w[3] = z * z;
            sum += w[3];
            z = max(0., -v.y + vxx); 
            w[5] = z * z;
            sum += w[5];
            z = max(0., v.x + vyy); 
            w[7] = z * z;
            sum += w[7];
            
            
            float g = exp(-3.125f * dot(v,v)) / sum;
            vec3 c2 = c*c;
            for (int k = 0; k < 8; ++k) {
                float wk = w[k] * g;
                m[k] += vec4(c * wk, wk);
                s[k] += c2 * wk;
            }
        }
        
    }
    
    vec4 ou = vec4(0.);
    for (k = 0; k < N; ++k) {
        m[k].rgb /= m[k].w;
        s[k] = abs(s[k] / m[k].w - m[k].rgb * m[k].rgb);

        float sigma2 = s[k].r + s[k].g + s[k].b;
        float w = 1.0f / (1.0f + pow(hardness * sigma2, q));

        ou += vec4(m[k].rgb * w, w);
    }

    outColor = clamp((ou / ou.w),0.0,1.0);
 }
]]>
</program>
</language>
</jittershader>
