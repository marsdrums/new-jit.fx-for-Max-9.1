<jittershader name="jit.fx.lineinterp.threshold">
	<param name="tex0" type="int" default="0" />
	<param name="uv" type="vec2" state="TEXCOORD" />
	<param name="texMat" type="mat4" state="TEXTURE0_MATRIX" />
	<param name="range" type="vec2" default="0.0 0.5" />
  <param name="rangemode" type="int" default="0" />
	<language name="glsl" version="1.5">
		<bind param="tex0" program="fp" />
		<bind param="uv" program="vp" />
		<bind param="texMat" program="vp" />
    <bind param="range" program="fp" />
    <bind param="rangemode" program="fp" />
		<program name="vp" type="vertex" source="fx.vp.unary.glsl" />

<program name="fp" type="fragment"  >
<![CDATA[
#version 330 core

layout (location = 0) out vec4 outColor;

uniform samplerJit0 tex0;
uniform vec2 range;
uniform int rangemode;

in jit_PerVertex {
	vec2 uv;
} jit_in;

vec3 rgb2hsl(vec3 c) {
    float r = c.r;
    float g = c.g;
    float b = c.b;

    float maxc = max(r, max(g, b));
    float minc = min(r, min(g, b));
    float h, s, l;
    l = (maxc + minc) * 0.5;

    if (maxc == minc) {
        // Achromatic
        h = 0.0;
        s = 0.0;
    } else {
        float d = maxc - minc;
        s = l > 0.5 ? d / (2.0 - maxc - minc) : d / (maxc + minc);

        if (maxc == r) {
            h = (g - b) / d + (g < b ? 6.0 : 0.0);
        } else if (maxc == g) {
            h = (b - r) / d + 2.0;
        } else {
            h = (r - g) / d + 4.0;
        }

        h /= 6.0;
    }

    return vec3(h, s, l);
}

float luma(){ 
  return dot(vec3(0.299,0.587,0.114), texelFetch(tex0, ivec2(jit_in.uv)).rgb);
}
/*
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 */
float hue() {
  return rgb2hsl( texelFetch(tex0, ivec2(jit_in.uv)).rgb).r;  
}

float saturation() {
  return rgb2hsl( texelFetch(tex0, ivec2(jit_in.uv)).rgb).g;  
}

float sobel(){
  vec3 n[9];
  n[0] = texture(tex0, jit_in.uv + vec2(-1.0, -1.0)).rgb;
  n[1] = texture(tex0, jit_in.uv + vec2(0.0, -1.0)).rgb;
  n[2] = texture(tex0, jit_in.uv + vec2(1.0, -1.0)).rgb;
  n[3] = texture(tex0, jit_in.uv + vec2(-1.0, 0.0)).rgb;
  n[4] = texture(tex0, jit_in.uv).rgb;
  n[5] = texture(tex0, jit_in.uv + vec2(1.0, 0.0)).rgb;
  n[6] = texture(tex0, jit_in.uv + vec2(-1.0, 1.0)).rgb;
  n[7] = texture(tex0, jit_in.uv + vec2(0.0, 1.0)).rgb;
  n[8] = texture(tex0, jit_in.uv + vec2(1.0, 1.0)).rgb;
  vec3 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);
  vec3 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);
  vec3 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));
  return dot(vec3(0.299,0.587,0.114), sobel);
}

float red(){
  return texelFetch(tex0, ivec2(jit_in.uv)).r;
}

float green(){
  return texelFetch(tex0, ivec2(jit_in.uv)).g;
}

float blue(){
  return texelFetch(tex0, ivec2(jit_in.uv)).b;
}

float alpha(){
  return texelFetch(tex0, ivec2(jit_in.uv)).a;
}


void main(void) 
{

  float val;

  switch (rangemode) {
      case 0:
          val = hue(); 
          break;
      case 1:
          val = saturation(); 
          break;
      case 2:
          val = luma(); 
          break;
      case 3:
          val = red(); 
          break;
      case 4:
          val = green(); 
          break;
      case 5:
          val = blue(); 
          break;
      case 6:
          val = alpha();
          break;
      case 7:
          val = sobel(); 
          break;

  }

  //float hue = luma(texelFetch(tex0, ivec2(jit_in.uv)).rgb);

  //float hue = get_hue(texelFetch(tex0, ivec2(jit_in.uv)).rgb);
	outColor.rgb = vec3(val >= range.x && val <= range.y);
  outColor.a = 1.0;
}

]]>
</program>
</language>
</jittershader>
